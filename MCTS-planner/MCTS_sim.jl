
using Plots
using BSON: @load, @save

algs_path_mac = "/Users/willpope/Desktop/Research/marmot-algs/"
algs_path = algs_path_mac

include(algs_path*"HJB-planner/HJB_functions.jl")
include(algs_path*"MCTS-planner/MCTS_functions.jl")

# values not symmetrical? check if number of nodes is equal in each branch
# fills out every node in first layer, why does it lose symmetry in second layer? some math reason?
#   - want to numerically check how filled each node is
#   - seems pretty symmetrical though
#   - may be due to how HJB grid is interpolated (rounding state up/down)

function mcts_sim(s_0, V_HJB, Dt, K_sub, A, gamma, std_v, std_phi, slv::Solver, EoM::Function, env::Environment, veh::Vehicle)
    s_hist = []
    a_hist = []
    path_hist = []

    s_k = s_0
    a_k = [0.0, 0.0]

    s_type = typeof(s_0)
    S = Dict{Int, Tuple{s_type, Int}}()
    Subpaths = Dict{Tuple{Int, Int}, Vector{s_type}}()

    step = 0
    end_run = false
    while end_run == false
        println("\nstep: ", step, " - - -")
        
        println("s_k: ", s_k)
        println("a_k: ", a_k)

        # propagates state to next time step
        s_k1, subpath_k1 = gen_state(s_k, a_k, std_v, std_phi, Dt, K_sub, EoM, veh)

        # runs MCTS to compute action for next time step
        if in_target_set(s_k1, env, veh) == false && in_workspace(s_k1, env, veh) == true && step <= 0
            # why is it printing S and Subpaths?
            @time a_k1, S, Subpaths = continuous_MCTS(s_k1, V_HJB, Dt, K_sub, A, gamma, std_v, std_phi, slv, EoM, env, veh)
            end_run = false
        else
            a_k1 = [0.0, 0.0]
            end_run = true
        end

        println("s_k1: ", s_k1)
        println("a_k1: ", a_k1)

        # stores state/action history
        push!(s_hist, s_k)
        push!(a_hist, a_k)
        push!(path_hist, subpath_k1)

        s_k = deepcopy(s_k1)
        a_k = deepcopy(a_k1)

        step += 1
    end

    push!(s_hist, s_k)
    push!(a_hist, a_k)

    return s_hist, a_hist, path_hist, S, Subpaths
end

# ISSUE: having trouble navigating around obstacles
#   - approaches opening, then decides that stopping is best action to take
#   - likely that each of root actions has at least one child node that hits obstacle
#   - backup incorporates value from each child into parent
#   - with shorter planning horizon (2 steps instead of 3), planner performs better around obstacle
#   - will decreasing gamma and/or c_UCB help? -> nope
#   - there's plenty of nodes in 3rd layer that are free of collision
#   - works for 2-deep tree, even when timestep is adjusted such that edge nodes are in same place as 3-deep tree

#   - check that update equation is correct, not sure if optimal action is being/should be considered
#   - seems like a bad node can poison a whole branch, even though that action would never be taken

#   - choice between small hit of going backwards or small hit of watered down collisions
#       - turns this into a tuning problem, which we don't want

# parameters ---
@load algs_path*"HJB-planner/bson/U_HJB.bson" U_HJB
@load algs_path*"HJB-planner/bson/env.bson" env
@load algs_path*"HJB-planner/bson/veh.bson" veh
V_HJB = -U_HJB

sims = 1e4
w_max = 1
d_max = 10
c_UCB = 100
# as c_UCB->inf, tree becomes fully symmetrical/balanced
#   - but should each node still take all actions at least once?
slv = Solver(sims, w_max, d_max, c_UCB)

# TO-DO: make these align with HJB, then later with POMDP
A_v = [-veh.c_vb, veh.c_vf]
A_phi = [-veh.c_phi, 0.0, veh.c_phi]

A = [[-veh.c_vb, -veh.c_phi],
    [-veh.c_vb, 0.0],
    [-veh.c_vb, veh.c_phi],
    [0.0, 0.0],
    [veh.c_vf, -veh.c_phi],
    [veh.c_vf, -2/3*veh.c_phi],
    [veh.c_vf, -1/3*veh.c_phi],
    [veh.c_vf, 0.0],
    [veh.c_vf, 1/3*veh.c_phi],
    [veh.c_vf, 2/3*veh.c_phi],
    [veh.c_vf, veh.c_phi]]

gamma = 0.98

std_v = 0.0
std_phi = 0.0

# TO-DO (?):
#   - add safety controller that checks path after MCTS has returned action
#   - if path intersects with obstacle, don't execute
#       - not sure if this would ever happen, especially with "stop" in action set
#   - if path intersects with goal region, stop execution at that time step
#       - this seems a bit heuristic, maybe agent wants to traverse target set for some reason?

Dt = 0.25
# rate = Rate(1/Dt)     # only in ROS
K_sub = 10   # NOTE: K_sub makes a big impact on solver's runtime

# s_0 = [-0.5, -6.5, 1/2*pi]
s_0 = [-1.8712791401729685, -3.535768769175535, 2.144544367702791]

println("\n\nstart --- --- ---\n")

s_hist, a_hist, path_hist, S, Subpaths = mcts_sim(s_0, V_HJB, Dt, K_sub, A, gamma, std_v, std_phi, slv, car_EoM, env, veh)

# plot path generated by mcts_sim()
p_path = plot(aspect_ratio=:equal, size=(750,1050), 
            xlabel="x-axis [m]", ylabel="y-axis [m]",
            xtick=range(-3,3), ytick=range(-7,7),
            title="MCTS Path Planner", 
            titlefontsize = 20,
            legend_font_pointsize = 11,
            top_margin = -4*Plots.mm,
            left_margin = 8*Plots.mm)

plot_polygon(p_path, env.W, 2, :black, "Workspace")
plot_polygon(p_path, env.T_xy, 2, :green, "Target Set")
plot_polygon(p_path, env.O_vec[1], 2, :red, "Obstacle")

plot!(p_path, getindex.(s_hist,1), getindex.(s_hist,2),
    linewidth=0, markercolor=:blue, markershape=:circle,
    label="")

for subpath in path_hist
    plot!(p_path, getindex.(subpath,1), getindex.(subpath,2),
        linecolor=:blue,
        label="")
end

V_c = pose_to_corners(s_0, veh)
V = [[V_c[1][1] V_c[1][2]];
    [V_c[2][1] V_c[2][2]];
    [V_c[3][1] V_c[3][2]];
    [V_c[4][1] V_c[4][2]]]

plot_polygon(p_path, V, 2, :blue, "")

V_c = pose_to_corners(s_hist[end], veh)
V = [[V_c[1][1] V_c[1][2]];
    [V_c[2][1] V_c[2][2]];
    [V_c[3][1] V_c[3][2]];
    [V_c[4][1] V_c[4][2]]]

plot_polygon(p_path, V, 2, :red, "")

for tup in collect(values(S))
    s = tup[1]
    if in_obstacle_set(s, env, veh) == true || in_workspace(s, env, veh) == false
        mcolor = :red
    else 
        mcolor = :black
    end

    plot!(p_path, [s[1]], [s[2]], 
        markershape=:circle, markersize=1, markercolor=mcolor, markerstrokewidth=0,
        label="")
end

display(p_path)